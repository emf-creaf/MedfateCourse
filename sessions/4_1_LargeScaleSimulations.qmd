---
title: "Landscape- and regional-scale simulations (practice)"
format:
  revealjs:
    incremental: true
    smaller: false
    logo: resources/img/emf_logo.svg
    theme: [default, resources/scss/custom.scss]
editor: source
author: "Miquel De Cáceres, Rodrigo Balaguer"
institute: "Ecosystem Modelling Facility, CREAF"
toc: false
toc-depth: 2
number-sections: false
slide-number: true
progress: true
---

```{r, eval = TRUE, include = FALSE}
library(medfateland)
```

## Outline

::::: columns
::: {.column width="60%"}
#### 1. Data structures in medfateland

#### 2. Spatially-uncoupled simulations

#### 3. Regional management scenarios

#### 4. Watershed-level simulations

#### 5. Creating spatial inputs I: forest inventory plots

#### 6. Creating spatial inputs II: continuous landscapes
:::

::: {.column width="40%"}
M.C. Escher - Belvedere, 1958
![](resources/img/Escher_belvedere.jpg)
:::
:::::

# 1. Data structures in medfateland

## Spatial structures (1) {.smaller}

+ Current versions of medfateland (ver. > 2.0.0) extensively use package **sf** (simple features) to represent spatial structures, where rows correspond to spatial units (normally point geometries) and columns include either *model inputs* (topography, forest, soil, weather forcing, etc.) or *model outputs*.

+ Essentially, an `sf` object is a data frame with spatial (geometry) information and a coordinate reference system.

+ Both `forest` and `soil` objects are nested in the corresponding columns of the `sf` object:

. . .

![](resources/img/data_structures.png){width="70%"}



::: footer
1. Data structures in medfateland
:::

## Spatial structures (2) {.smaller}

If we load the package we can inspect the structure of an example dataset with 100 forest inventory plots:

```{r, echo = TRUE}
example_ifn
```

. . .

Accessing a given position of the `sf` object we can inspect `forest` or `soil` objects:
```{r, echo = TRUE}
example_ifn$soil[[3]]
```


::: footer
1. Data structures in medfateland
:::

## Spatial structures (3) {.smaller}

To perform simulations on a gridded landscape we require both an `sf` object and an object `SpatRaster` from package **terra**, which defines the raster topology. For example, the following `sf` describes 65 cells in a small watershed:

```{r, echo = TRUE}
example_watershed
```

. . .

The following code defines a 100-m raster topology with the same CRS as the watershed:

```{r, echo = TRUE}
r <-terra::rast(xmin = 401380, ymin = 4671820, xmax = 402880, ymax = 4672620, 
                nrow = 8, ncol = 15, crs = "epsg:32631")
r
```


::: footer
1. Data structures in medfateland
:::

## Weather forcing in medfateland {.smaller}

There are three ways of supplying weather forcing to simulation functions in **medfateland**, each with its own advantages/disadvantages:

| Supply method  | Advantages            | Disadvantages            |
|----------------|-----------------------|--------------------------|
| A data frame as parameter `meteo` | Efficient both computationally and memory-wise   | Assumes weather is spatially constant |
| A column `meteo` in `sf` objects | Allows a different weather forcing for each spatial unit | The resulting `sf` is often huge in memory requirements |
| An interpolator object of class `stars` (or a list of them) as issued from package **meteoland** | More efficient in terms of memory usage | Weather interpolation is performed during simulations, which entails some computational burden |

. . .

::: {.callout-tip}
+ If a list of interpolator objects is supplied, each of the interpolators should correspond to a different, consecutive, non-overlapping time period (e.g. 5-year periods). 
+ Taken together, the interpolators should cover the simulated target period. 
+ The simulation function will use the correct interpolator for each target date.
:::

::: footer
1. Data structures in medfateland
:::


# 2. Spatially-uncoupled simulations

## Spatially-uncoupled simulation functions {.smaller}


:::: {.columns}

::: {.column width="50%"}

+ Spatially-uncoupled simulations are those where simulations in different stands are completely independent.
+ This situation is where *parallelization* is more advantageous. 
+ Following the nested models of **medfate**, **medfateland** offers functions `spwb_spatial()`, `growth_spatial()` and `fordyn_spatial()` for uncoupled simulations [^1].

:::
::: {.column width="50%"}

![](resources/img/Package_design_medfateland.png)

:::
::::

. . .

[^1]: There exist `spwb_spatial_day()` and `growth_spatial_day()` for single-day simulations, paralleling `spwb_day()` and `growth_day()` in **medfate**.


::: footer
2. Spatially-uncoupled simulations
:::

## Running spatially-uncoupled simulations {.smaller}


Since it builds on **medfate**, simulations using **medfateland** require *species parameters* and *control parameters* for local simulations:

```{r, echo = TRUE}
data("SpParamsMED")
local_control <- defaultControl()
```

. . .

We can specify the target simulation period as a vector of `Date` or subset the target plots:

```{r, echo = TRUE}
dates <- seq(as.Date("2001-01-01"), as.Date("2001-01-31"), by="day")
example_subset <- example_ifn[1:5, ]
```

. . .

If we are interested in water (or energy) balance, we can use function `spwb_spatial()` as follows:

```{r, echo = TRUE}
res <- spwb_spatial(example_subset, SpParamsMED, examplemeteo, 
                    dates = dates, local_control = local_control)
```

. . .

The output is an `sf` object as well, where column `result` contains the results of calling `spwb()` and column `state` contains the final status of `spwbInput` objects:
```{r, echo = FALSE}
res
```


::: footer
2. Spatially-uncoupled simulations
:::

## Using summary functions (1) {.smaller}

Simulations with **medfate** can generate a lot of output. This can be reduced using `control` parameter, but simulation output with **medfateland** can require a lot of memory.

. . .

To save memory, it is possible to generate temporal summaries automatically after the simulation of each target forest stand, and avoid storing the full output of the simulation function (using `keep_results = FALSE`).

. . .

The key element here is the **summary function** (and possibly, its parameters), which needs to be defined and supplied.

. . .

In the following call to `spwb_spatial()` we provide the summary function for `spwb` objects available in **medfate**: 

```{r, echo = TRUE}
res_2 <- spwb_spatial(example_subset, SpParamsMED, examplemeteo, 
                  dates = dates, local_control = local_control,                  
                  keep_results = FALSE,
                  summary_function = summary.spwb, summary_arguments = list(freq="months"))
res_2
```


::: footer
2. Spatially-uncoupled simulations
:::

## Using summary functions (2) {.smaller}

We can access the simulation summary for the first stand using:
```{r, echo = TRUE}
res_2$summary[[1]]
```

. . .

Summaries can be generated *a posteriori* for a given simulation, using function `simulation_summary()`, e.g.:

```{r, echo = TRUE}
simulation_summary(res, summary_function = summary.spwb, freq="months")
```


. . .

::: {.callout-tip}
Learning how to define summary functions is a good investment when using **medfateland**.
:::

::: footer
2. Spatially-uncoupled simulations
:::

## Continuing a previous simulation {.smaller}

The result of a simulation includes an element `state`, which stores the state of soil and stand variables at the end of the simulation. This information can be used to perform a new simulation from the point where the first one ended. 

. . .

In order to do so, we need to update the state variables in spatial object with their values at the end of the simulation, using function `update_landscape()`:

```{r, echo = TRUE}
example_mod <- update_landscape(example_subset, res)
example_mod
```

Note that `example_mod` contains a new column `state` with initialized inputs. 

. . .

Finally, we can call again the simulation function for a new consecutive time period:

```{r, echo = TRUE}
dates <- seq(as.Date("2001-02-01"), as.Date("2001-02-28"), by="day")
res_3 <- spwb_spatial(example_mod, SpParamsMED, examplemeteo, 
                      dates = dates, local_control = local_control)
```


::: {.callout-important}
Function `update_landscape()` will also modify column `soil`.
:::

::: footer
2. Spatially-uncoupled simulations
:::

# 3. Regional management scenarios

## Function `fordyn_scenario()` {.smaller}


:::: {.columns}

::: {.column width="50%"}

+ Function  `fordyn_spatial()` allows running simulations of forest dynamics for a set of forest stands, possibly including forest management and stand-specific silviculture prescriptions.
+ However, in `fordyn_spatial()` simulated stand dynamics are **uncoupled**.
+ Function `fordyn_scenario()` allows simulating forest dynamics on a set of forest stands while evaluating a demand-based **management scenario**. 
+ Considering the management scenario leads to a relationship in the management actions on forest stands, hence **coupling simulations**. 
+ Running management scenarios is a complex task, we will cover all details in this tutorial.
:::
::: {.column width="50%"}

![](resources/img/Package_design_medfateland.png)

:::
::::


::: footer
3. Regional management scenarios
:::

## Management units and prescriptions (1) {.smaller}

Management scenarios require classifying forest stands into **management units**. Each management unit can be interpreted as a set of stands that are managed following the same prescriptions. 

. . .

Management units can be arbitrarily defined, but here we will define them on the basis of **dominant tree species**. 

. . .

The following code allows determining the dominant tree species in each of the 5 forest stands:

```{r, echo = TRUE}
example_subset$dominant_tree_species <- sapply(example_subset$forest,
                                               stand_dominantTreeSpecies, SpParamsMED)
example_subset$dominant_tree_species
```

. . .

The package includes a table with **default prescription parameters** for a set of species, whose columns are management parameters:

```{r, echo = TRUE}
names(defaultPrescriptionsBySpecies)
```

. . .

whereas the rows correspond to species or species groups, whose names are:

```{r, echo = TRUE}
head(defaultPrescriptionsBySpecies$Name)
```

::: footer
3. Regional management scenarios
:::

## Management units and prescriptions (2) {.smaller}

To specify the management unit for stands, we first define a column management_unit with missing values:
```{r, echo = TRUE}
example_subset$management_unit <- NA
```

. . .

and then assign the corresponding row number of `defaultPrescriptionsBySpecies` for stands dominated by each species where management is to be conducted:

```{r, echo = TRUE}
example_subset$management_unit[example_subset$dominant_tree_species=="Pinus sylvestris"] <- 14
example_subset$management_unit[example_subset$dominant_tree_species=="Quercus ilex"] <- 19
example_subset$management_unit[example_subset$dominant_tree_species=="Quercus pubescens"] <- 23
example_subset[,c("id", "dominant_tree_species", "management_unit")]
```

. . .

In this example stands dominated by *Quercus faginea* are not harvested.

::: footer
3. Regional management scenarios
:::

## Management scenarios and represented area {.smaller}

**Management scenarios**

Management scenarios are defined using function `create_management_scenario()` [^2].

[^2]: Three different kinds of scenarios are allowed in `create_management_scenario()`, two of them being demand-based.

. . .

Demand-based management scenarios require specifying the demand in annual volume [^3].

[^3]: The fact that demand is specified in volume entails that simulations need to be able to estimate timber volume for any given tree. In practice, this requires specifying a **volume_function**. See `?fordyn_scenario` for details.

```{r, echo = TRUE}
scen <- create_management_scenario(units = defaultPrescriptionsBySpecies, 
                                   annual_demand_by_species = c("Quercus ilex/Quercus pubescens" = 1300,
                                                                "Pinus sylvestris" = 500))
```

. . .

Note that in this case the timber obtained from *Q. ilex* or *Q. pubescens* will be subtracted from the same annual demand.

. . .

We can check the kind of management scenario using:

```{r, echo = TRUE}
scen$scenario_type
```

. . .


**Represented area**

Finally, it is necessary to specify the area (in ha) that each forest stand represents, because all timber volumes are defined at the stand level in units of **m3/ha**, whereas the demand is in units of **m3/yr**.

. . . 

In our example, we will assume a constant area of 100 ha for all stands:

```{r, echo = TRUE}
example_subset$represented_area_ha <- 100
```

::: footer
3. Regional management scenarios
:::

## Launching simulations {.smaller}

We are now ready to launch the simulation of the management scenario using a call to function `fordyn_scenario()`. 

```{r, echo = TRUE, eval = TRUE}
fs <- fordyn_scenario(example_subset, SpParamsMED, meteo = examplemeteo, 
                      management_scenario = scen,
                      parallelize = TRUE)
```

. . .

::: {.callout-tip}
We will often set `parallelize = TRUE` to speed-up calculations (`fordyn_scenario()` makes internall calls to `fordyn_spatial()` for each simulated year). 
:::

. . .

Function `fordyn_scenario()` returns a list whose elements are:

```{r, echo = TRUE, eval = TRUE}
names(fs)
```

. . .

Stand-level results are available in element `result_sf`, whose columns should be easy to interpret if you have experience with `fordyn()`:

```{r, echo = TRUE, eval = TRUE}
fs$result_sf
```


::: footer
3. Regional management scenarios
:::

# 4. Watershed-level simulations

## Watershed-level simulation functions {.smaller}


:::: {.columns}

::: {.column width="50%"}
* Package **medfateland** allows conducting simulations of forest function and dynamics on a set of forest stands while including **lateral water transfer processes**. 
* Similar to other models such as TETIS [^4], three lateral flows are considered between adjacent cells:
    + Overland surface flows from upper elevation cells.
    + Lateral saturated soil flows (i.e. interflow) between adjacent cells.
    + Lateral groundwater flow (i.e. baseflow) between adjacent cells.
* Following the nested models of **medfate**, **medfateland** offers functions `spwb_land()`, `growth_land()` and `fordyn_land()` for watershed-level simulations [^5].
* Here we will cover the basics of watershed simulations only.

:::
::: {.column width="50%"}

![](resources/img/Package_design_medfateland.png)

:::
::::




. . .

[^4]: Francés et al. (2007) Journal of Hydrology, 332, 226–240.
[^5]: There exist `spwb_land_day()` and `growth_land_day()` for single-day simulations, paralleling `spwb_spatial_day()` and `growth_spatial_day()`.


::: footer
4. Watershed-level simulations
:::

## Model inputs (1) {.smaller}

**Spatial structures**

To perform simulations on a gridded landscape we require both an `sf` object: 

```{r, echo = TRUE}
example_watershed
```

. . .

and a `SpatRast` topology with the same coordinate reference system:

```{r, echo = TRUE}
r <-terra::rast(xmin = 401380, ymin = 4671820, xmax = 402880, ymax = 4672620, 
                nrow = 8, ncol = 15, crs = "epsg:32631")
r
```


::: footer
4. Watershed-level simulations
:::

## Model inputs (2) {.smaller}

**Land cover type**

Simulations over watersheds normally include different land cover types. These are described in column land_cover_type:

```{r, echo = TRUE}
table(example_watershed$land_cover_type)
```

. . .

**Aquifer and snowpack**

Columns `aquifer` and `snowpack` are used as state variables to store the water content in the aquifer and snowpack, respectively.

. . .

**Crop factors**

Since the landscape contains agricultural lands, we need to define crop factors, which will determine transpiration flow as a proportion of potential evapotranspiration:

```{r, echo = TRUE}
example_watershed$crop_factor = NA
example_watershed$crop_factor[example_watershed$land_cover_type=="agriculture"] = 0.75
```

. . .

**Watershed control options**

Analogously to local-scale simulations with **medfate**, watershed simulations have overall control parameters. Notably, the user needs to decide which sub-model will be used for lateral water transfer processes (at present, only `"tetis"` is available):

```{r, echo = TRUE}
ws_control <- default_watershed_control("tetis")
```


::: footer
4. Watershed-level simulations
:::


## Launching simulations {.smaller}

As with other functions, we may specify a simulation period (subsetting the weather input):

```{r, echo = TRUE}
dates <- seq(as.Date("2001-01-01"), as.Date("2001-01-31"), by="day")
```

When calling the simulation function, we must provide the raster topology, the input `sf` object, among other inputs:

```{r, echo = TRUE}
res_ws <- spwb_land(r, example_watershed, SpParamsMED, examplemeteo, 
                    dates = dates, 
                    local_control = local_control,
                    watershed_control = ws_control, 
                    progress = FALSE)
     
```

. . .

::: {.callout-important}
Remember, watershed simulations require both control parameters for **local processes** and  control parameter for **watershed processes**.
:::

::: footer
4. Watershed-level simulations
:::

## Simulation output (1) {.smaller}

As usual, the output of `spwb_land()` is a named list.
```{r, echo = TRUE}
names(res_ws)
```


. . .

Where `sf` is analogous to those of functions `*_spatial()`, containing final state of cells as well as cell-level summaries:

```{r, echo = TRUE}
res_ws$sf
```

::: footer
4. Watershed-level simulations
:::

## Simulation output (2) {.smaller}

In addition, element `watershed_balance` contains daily values of the water balance at the watershed level:

```{r, echo = TRUE}
head(res_ws$watershed_balance)
```


::: footer
4. Watershed-level simulations
:::

## Advanced topics {.smaller}

The following table summarises a set of advanced topics for watershed simulations.

| Topic    | Description                                |
|------------|--------------------------------------------|
| Burn-in    | Watershed simulations always require burn-in periods where soil and aquifer levels reach equilibrium values. This is facilitated via function  `update_landscape()`. |
| Calibration | Watershed simulations will normally require calibration of watershed-level control parameters. |
| Weather resolution | Weather interpolation can have a **coarser resolution** than the watershed grid (see `weather_aggregation_factor` in `?default_watershed_control`). |
| Parallelization | At present, **parallelization is not recommended** for watershed simulations. |
| Result cells | Whereas by default only water balance summaries are produced for individual cell, it is possible to specify full **medfate** results on target cells, via a column called `result_cell`. |
| Local control | Analogously to weather forcing, it is possible to specify spatial variation in the control parameters for local processes (e.g. Sperry or Sureau only in targetted cells), via a column called `local_control`. |


::: footer
4. Watershed-level simulations
:::

---

M.C. Escher - Belvedere, 1958

![](resources/img/Escher_belvedere.jpg)
